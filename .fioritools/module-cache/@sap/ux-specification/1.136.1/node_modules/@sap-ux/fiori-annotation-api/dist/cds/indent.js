"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIndentLevelFromPointer = getIndentLevelFromPointer;
exports.getIndentLevelFromNode = getIndentLevelFromNode;
const odata_annotation_core_1 = require("@sap-ux/odata-annotation-core");
const cds_odata_annotation_converter_1 = require("@sap-ux/cds-odata-annotation-converter");
const pointer_1 = require("./pointer");
const cds_compiler_tokens_1 = require("./cds-compiler-tokens");
const printOptions = { ...odata_annotation_core_1.printOptions, useSnippetSyntax: false };
const ANNOTATE_PATTERN = /annotate/i;
/**
 * Finds the indentation level matching to the node of a pointer.
 *
 * @param document - CDS document root.
 * @param tokens - All tokens in the document.
 * @param pointer - Pointer to a node for which indentation will be returned.
 * @returns Indentation level of the node matching the pointer.
 */
function getIndentLevelFromPointer(document, tokens, pointer) {
    const path = (0, pointer_1.getAstNodesFromPointer)(document, pointer).reverse();
    const node = path.shift();
    if (!node) {
        return 0;
    }
    return getIndentLevelFromNode(tokens, node);
}
/**
 * Finds the indentation level of a node.
 *
 * @param tokens - All tokens in the document.
 * @param node - Node for which indentation will be returned.
 * @returns Indentation level of the node.
 */
function getIndentLevelFromNode(tokens, node) {
    const width = printOptions.useTabs ? 1 : printOptions.tabWidth;
    const startCharacter = getLineStartCharacter(node, tokens);
    const indentLevel = startCharacter / width;
    return Math.floor(indentLevel);
}
function getLineStartCharacter(node, tokens) {
    if (!node?.range) {
        return 0;
    }
    if (node.type === cds_odata_annotation_converter_1.TARGET_TYPE && node.range) {
        const token = (0, cds_compiler_tokens_1.findLastTokenBeforePosition)(ANNOTATE_PATTERN, tokens, node.range.end);
        if (node.kind === 'element' && node.nameRange) {
            const range = token ? (0, cds_compiler_tokens_1.createTokenRange)(token) : undefined;
            if (token && range?.start?.line === node.nameRange.start.line) {
                // element is in the same line as the annotate statement, so we should use the indent level of the annotate statement
                return (0, cds_compiler_tokens_1.tokenColumn)(token);
            }
            return node.nameRange.start.character;
        }
        if (token) {
            return (0, cds_compiler_tokens_1.tokenColumn)(token);
        }
    }
    const token = findFirstTokenOfLine(tokens, node.range.start.line);
    return token ? (0, cds_compiler_tokens_1.tokenColumn)(token) : 0;
}
function findFirstTokenOfLine(tokens, nodeLine) {
    // use binary search to find a token at the same line
    let left = 0;
    let right = tokens.length;
    while (left <= right) {
        const middle = Math.floor((left + right) / 2);
        let token = tokens[middle];
        const line = (0, cds_compiler_tokens_1.tokenLine)(token);
        if (line < nodeLine) {
            left = middle + 1;
        }
        else if (line > nodeLine) {
            right = middle - 1;
        }
        else {
            // we found a token in correct line, search for first token of the line
            let index = middle - 1;
            let previousToken = tokens[index];
            while (previousToken && line === (0, cds_compiler_tokens_1.tokenLine)(previousToken)) {
                token = previousToken;
                previousToken = tokens[index];
                index--;
            }
            return token;
        }
    }
    return undefined;
}
//# sourceMappingURL=indent.js.map